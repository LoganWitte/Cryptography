# Rohan Sangani, modified by Logan Witte
# 11/3/2025, modified 12/1/2025
# Simple Example Illustrating Elliptic Curve Cryptography, modified for Hw7 Problem 2
# Adapted from https://www.cs.ucf.edu/~dmarino/ucf/cis3362/progs/ECC.java

import random

from EllipticCurve import EllipticCurve
from Point import Point

class ECC:
    def __init__(self, c, x, y, n_a):
        self.curve = c
        self.generator = Point(c, x, y)
        self.private_key = n_a
        self.public_key = self.generator * self.private_key

    # Assumes plainText is proper blocksize.
    def encryptBlock(self, plainText):
        xVal = convert(plainText)
        plainPt = self.convertMsgToPoint(xVal, 8*len(plainText))
        print("Plain point is")
        print(plainPt)
        return self.encryptPoint(plainPt)

    # Encrypts a single point, returning a list of points [c1,c2] representing the ciphertext
    def encryptPoint(self, plain):
        bits = self.curve.p.bit_length() # same as this.curve.getP().bitLength()
        k = random.getrandbits(bits) # same as new BigInteger(bits, new Random())
        print(f"Picked {k=} for encryption")

        # return both parts of the cipher text
        ans = [self.generator * k, plain + (self.public_key * k)]
        return ans

    # Similar to El-Gamal
    def decryptPoint(self, cipher):
        sub = cipher[0] * self.private_key

        #print(f"Decryption result is: {cipher[1]} - {sub}")
        res = cipher[1] - sub
        #print("As a single point its")
        #print(res)
        #print()
        return res

    # Returns the corresponding numeric message for the plaintext point
    # plainPoint when the message is numbits number of bits.
    def decryptPointToMsg(self, plainPoint, numbits):
        return plainPoint.x & ( (1<<numbits)-1 )

    # Decrypts the cipherTextPt assumed to be one block that is numbits
    # long. numbits must be a multiple of 8.
    def decryptBlock(self, cipherTextPt, numbits):
        plainPt = self.decryptPoint(cipherTextPt)
        plainVal = self.decryptPointToMsg(plainPt, numbits)
        return convertBack(plainVal, numbits//8)

    # This method takes in a numeric plaintext message numMsg, which is to
    # be stored in numbits number of bits and returns a corresponding point
    # that can be used for ECC as the corresponding plaintext point.
    # The prime for the curve needs to be larger than numbits bits.
    # I recommend at least 4 to 8 extra bits. For big numbers probably 8.
    def convertMsgToPoint(self, numMsg, numbits):

        limit = self.curve.p
        tempx = 0
        tempy = 0

        # i is my extra most significant bits for the x value.
        for i in range(limit):

            # So the x value we are trying is 2 to the power numbits times i plus numMsg.
            tempx = (i<<numbits) + numMsg

            # Get a matching y value.
            tempy = self.curve.getMatchingY(tempx)

            # I am not going to use points of the form (x,0).
            if tempy != None and tempy != 0:
                break

        # Here is the corresponding point.
        return Point(self.curve, tempx, tempy)

    # toString()
    def __str__(self):
        return (f"Generator: {self.generator}\n"
                f"Private Key: {self.private_key}\n"
                f"Public Key: {self.public_key}")

# Treating each byte as 0 to 256. Converts string to integer value.
def convert(s):
    res = 0
    for i in range(len(s)):
        res = 256*res + ord(s[i])
    return res

# Converts an integer storing numChars characters back to a string.
def convertBack(num, numChars):
    res = ""
    for i in range(numChars):
        res = chr(num%256) + res
        num = num//256
    return res
    
def H7P2():

    # Given in problem #2
    x = 54806146079202012149863304384238981612689733970573090585106709657142943880944339
    a = 36446283523087502287115183071389950645992053298406200073486092483910556512631903
    b = 42734816158623087150418558930008792737532128656103939550753598723374192037914999
    gx = 21800546263211886648851134754136248466335681616259043683140052641809537493123316
    gy = 7567838202715993970228257461140116882989327469665445487599596243485285983706793

    # Found in problem #1
    nA = 6342379028871672578799006438375742821981052796152446398587360791435451555403625

    # Makes the curve and point
    myC = EllipticCurve(x, a, b)
    myG = Point(myC, gx, gy)
    myECC = ECC(myC, gx, gy, nA)

    ciphertext = [(20609541161242098971051772005104918063511641663792351424134195501663011077148061, 7084958555458429082889063480393798713831192571668740476581401196187483305109863),
(14356342354465719861521545719659358882117611363937570963666282000577166174224238, 52213488809349268629195819311593882390799087528324708869987216023974009898029481),
(46203242017168263200446352255453255080242720694875045358945591652970096025638611, 7779538791892564992153204398242412856229964436472500416735147103043035780212269),
(28856072567960824744166972360585119126054339153828829080082903899043194703461401, 26379166802475436300590162734438904708896962851032038864133940573932245969291082),
(27799685849316228701804673029185878385486738676214978014886250895948455813985621, 43519606287198327524365454368144599984257603593478393168814581063909419063250532),
(11608594533289749981931249827629520171016367328418009001456341884958783467090499, 694222147045657942897604346351740074022048683812688039660289961283868446263047),
(3366342295788472614707761050518553393990124168101089250551529144597698721182344, 17910079282731983481450728360848307016982035763988243833745606562433246940881260),
(50672781670458882504586540763721116266199590591265276740319660793369325974822624, 4322465239099523093465513696625197878599575241271163682065708078250011672647427),
(40514838945439894859505279686672843409023530953531949343100068401723100116335152, 18769221775051844630368794771980303487635395466145569979347690119869521286953840),
(43160749760835323084690201017910164805518101814270293895922535285326713678971902, 52365138251480294368289314798801310647709738099520145290752656174785617348221068),
(7839284849026206100894136251753541442434171154167591033067885581776277643409546, 29339521777406705093083561844374280750575559244592334488830021247237808659125974),
(26766006347550113671129816278991786927021099332158985337865916741745978324564268, 54261067459090898746768906207718070051296747722137543639764160832518432203962421),
(40317673693148656198689826593467006052344430512864080027428852350461371429320036, 16784040406904946707481211665164817227766146950100747280421609427610830237965478),
(22180761220873836586837845757399264630527793182714710240097585389968308199327015, 41960441657429900311633935498165908426276590398421049118355344073173668934643376),
(28860501727452620011994290712546587571842930960922905020469622131430059938922644, 51113735139292619308840229375166093621929263451781732152329241933287720320238764),
(45614069750628683402859462741840728805924892969420421162385874811528817450484273, 28356517936779327262703630796263980267015434416777530183299140360507410822708299),
(53413163504920483597062910929557971272003083902497620669303764720558481589362133, 39698644356325250338910247756385738626239551392453266324502756974522077074931478),
(48438567688331275296272460655971019568204325567195068457931945902013725435146624, 50869558540603338240045977022731712319362012334782808634210620224727405030911625),
(7062358792208133300586407105890962122457814741908390154807524121263239496962292, 30370770685835506853866454546235029447936105223046811808411711221986187693349205),
(34880676613260416174951320671593860881418686164867590498023832845690916462000329, 21899068511931224120883895969538050542248686195899075768441430254140011086173589),
(25404658941358706260316753310878666295647685744410090630034765955911322092900206, 35902350704869126238270961449559216876365192567551415021960457685794740655942711),
(16912249836934506769367862395328884139521837858466569826333642094585330341526205, 39434057766078877370087681798052488257772372756021984329110543112835664339264204),
(1409522394661449014966283902311447096077722997193613082535069556927930536413275, 14097527007380187417736287284916453156160915293484381405887590813079477708356817),
(32681029334896910627031024118525619994407533126417022709776198043986135001433217, 4383279055029005197365374156142757172042090117925634101839615193127729075894639),
(42021477938776938907725720793214168193966611915948606776115541367456468259312078, 4262178630393344852190423109342477978555839455647763648495067083356708260267258),
(33971158250804342659169848167231150611802701053709196727584206618026572836851722, 44824143996964490746278991583927605180138946016950839566273562138409965739336460),
(16292824087190032551133494901225166883624395494447802800230540802694693470700120, 21303600798179409902620851030328541511060388748779763742906463482448480559206778),
(11254257944703988191626104913278821985596902484632814812965714881371459202304745, 10451867662030072920714800079940590180511909327595733291351696377401611373139484),
(4856572838055698524720411238234465739472979025366373180663571075082799848146086, 23540227144934179982871157246049334051091217654557772799339233603754505620046536),
(2422098645374725005570466782935829223776944507157333634738531548397823137060118, 33540551382459861976010698956380266919852072256255816540826767817173463939287251),
(43066943222539838007283237489102135705220549462449432087785242387326679882211058, 7849473688624189956877922878103823414987126704629133861486720035479191546198314),
(49716318178875453205239753444602854598053024651638153754603353386132239809560162, 12431004730186878268399683098287745487693984372031400774072739121917128152387672),
(12075721005701002311117939602824022261713482288745303923436304400407237298133492, 53532032454527528630389402647603313815124780332574405405775390047627741973508620),
(30320658902681222484197380868962918861923139504001047439434983613118986081434467, 24160483887072453935085928358275516994308259506672752068989790163838302282748991)]

    for i in range(0, len(ciphertext), 2):
        c1 = ciphertext[i]
        c2 = ciphertext[i+1]
        c1Point = Point(myC, c1[0], c1[1])
        c2Point = Point(myC, c2[0], c2[1])
        cipherPoint = [c1Point, c2Point]
        msg = myECC.decryptBlock(cipherPoint, 256)
        print(msg)

H7P2()